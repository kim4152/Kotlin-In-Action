# 8장: 고차 함수

- 고차함수 : 람다를 인자로 받거나 반환하는 함수
- 인라인 함수 : 람다를 사용함에 따라 발생할 수 있는 성능상 부가 비용을 없애고 람다 안에서 더 유연하게 흐름을 제어할 수 있는 함수


1. 코틀린이 보통 람다를 무명 클래스로 컴파일하지만 그렇다고 람다 식을 사용할 때마다 새로운 클래스가 만들어지지는 않는다.
   -> 컴파일러는 람다를 클래스로 명시적으로 생성하는 대신 바이트코드 수준에서 람다를 처리한다.

2. 람다가 변수를 포획하면 람다가 생성되는 시점마다 새로운 무명 클래스 객체가 생긴다. 이런 경우 실행 시점에 무명 클래스 생성에 따른 부가 비용이 든다.

```kotlin
var count = 0
repeat(3) {
    /*
    람다가 외부 변수를 참조하거나 사용 -> 포획(capture)
    포획이 있는 람다는 클로저라고 한다.
    */
    val a: () -> Unit = { count++ }
    val b: () -> Unit = { }
    println(a.hashCode())   // 다른 객체
    println(b.hashCode())   // 같은 객체
}
```

---

inline 변경자를 어떤 함수에 붙이면 컴파일러는 그 함수를 호출하는 모든 문장을 함수 본문에 해당하는 바이트코드로 바꿔치기 해준다.   
호출된 함수의 본문이 호출한 함수의 바이트코드에 직접복사(inline)된다.

1. 스택 생성과 호출.리턴 작업이 필요없어짐.
2. 람다 객체 생성되지 않음
3. 실체화한 타입 파라미터 사용 가능 -> 9장에서 설명

### inline 한계

```kotlin
// 파라미터로 받은 람다를 다른 변수에 저장하고 나중에 그 변수를 사용한다면 람다를 표현하는 객체가 어딘가에는 존재해야 하기 때문에 람다를 인라이닝할 수 없다
inline fun b(block: () -> Unit) {
    val storedBlock = block  // 람다를 변수에 저장 (오류)
    println("람다를 변수에 저장했습니다.")
    storedBlock()            // 나중에 람다 실행
}
```

위 코드는 컴파일 오류를 발생시킴.  
이유 :  
인라인 함수는 람다의 바디를 호출 지점에 복사해야하지만, 람다를 변수에 저장하면 그 변수에 대한 객체화가 필요하다.  
block을 변수에 저장하게 되면 그 변수에 대한 객체화가 필요하다.  
즉, 파라미터로 받은 람다를 변수에 저장하면 객체화가 필요하므로 인라인 불가능  
객체화가 필요하면 인라인이 불가능한 이유는?  
인라인 함수의 목적은 함수 호출을 없애고 람다 객체를 생성하지 않기 위함이기 때문.

### 해결 : noinline

```kotlin
inline fun c(noinline block: () -> Unit, anotherBlock: () -> Unit) {
    val storedBlock = block  // 람다를 변수에 저장
    println("람다를 변수에 저장했습니다.")
    storedBlock()            // 나중에 람다 실행
}
```

## 시퀀스와 인라인

map{ } 과 filter{ } 는 inline 함수이다.  
이 때, asSequence를 사용하면 각 중간 시퀀스는 람다를 필드에 저장하는 객체로 표현되며, 시퀀스는 람다를 저장해야하므로 인라인하지 않는다.    
따라서 모든 컬렉션 연산에 asSequence를 붙여서는 안된다.    
크기가 작은 컬렉션은 오히려 일반 컬렉션 연산이 더 성능이 나올 수 있다.

1. map {} 및 filter {}와 같은 함수 (즉시 평가):  
   • 새로운 컬렉션 객체를 바로 생성.  
   • 이때 람다식은 inline 함수이기 때문에 함수 호출 오버헤드 없이 인라인.  
   • 따라서 람다식이 추가적인 객체로 저장되지 않는다.
2. asSequence를 사용한 map {} 및 filter {} (지연 평가):  
   • 즉시 실행되지 않고, 각 단계(중간 연산)가 객체로 표현.  
   • 여기서 각 중간 연산은 람다식을 필드로 저장해야 하므로, inline 함수가 적용되지 않는다.  
   • 결과적으로 중간 시퀀스를 관리하는 객체와 람다 객체가 생성.

여기저기 inline을 붙인다고 좋아지는게 아니다.  
람다를 인자로 받는 함ㅎ수만 성능이 좋아질 가능성이 높다.

람다를 인자로 받는 함수를 인라이닝하면 좋은 점

1. 호출 비용 감소
2. 람다를 표현하는 클래스와 람다 인스턴스에 해당하는 객체를 만들 필요 없어짐
3. JVM은 함수 호출과 람다를 인라이닝해 줄 정도로 똑똑하지 못하다.
4. 일반 람다에서 사용할 수 없는 몇 가지 기능 사용 가능 -> 넌로컨(non-local) : return을 사용하면 람다로부터만 반환되는 게 아니라 그 람다를 호출하는 함수가 실행을 끝내고 반환

주의점

- 코드 크기
  본문 바이트코드를 모든 호출 지점에 복사해 넣고 나면 바이트코드가 전체적으로 아주 커져있을 수 있다.  
  코틀린 표준 라이브러리가 제공하는 인라인 함수는 크기가 아주 작다.
